diff --git a/whisper/mailserver/mailserver.go b/whisper/mailserver/mailserver.go
index 57e6505..77727ef 100644
--- a/whisper/mailserver/mailserver.go
+++ b/whisper/mailserver/mailserver.go
@@ -88,17 +88,22 @@ func (s *WMailServer) Close() {
 	}
 }
 
-func (s *WMailServer) Archive(env *whisper.Envelope) {
+func (s *WMailServer) Archive(env *whisper.Envelope) ([]byte, error) {
 	key := NewDbKey(env.Expiry-env.TTL, env.Hash())
 	rawEnvelope, err := rlp.EncodeToBytes(env)
 	if err != nil {
-		log.Error(fmt.Sprintf("rlp.EncodeToBytes failed: %s", err))
-	} else {
-		err = s.db.Put(key.raw, rawEnvelope, nil)
-		if err != nil {
-			log.Error(fmt.Sprintf("Writing to DB failed: %s", err))
-		}
+		err := fmt.Errorf("rlp.EncodeToBytes failed: %s", err)
+		log.Error(err.Error())
+		return nil, err
 	}
+
+	if err = s.db.Put(key.raw, rawEnvelope, nil); err != nil {
+		err := fmt.Errorf("Writing to DB failed: %s", err)
+		log.Error(err.Error())
+		return nil, err
+	}
+
+	return key.raw, nil
 }
 
 func (s *WMailServer) DeliverMail(peer *whisper.Peer, request *whisper.Envelope) {
diff --git a/whisper/whisperv6/doc.go b/whisper/whisperv6/doc.go
index 2fcc9e6..df7b063 100644
--- a/whisper/whisperv6/doc.go
+++ b/whisper/whisperv6/doc.go
@@ -93,7 +93,7 @@ func (e unknownVersionError) Error() string {
 // DeliverMail should use directMessagesCode for delivery,
 // in order to bypass the expiry checks.
 type MailServer interface {
-	Archive(env *Envelope)
+	Archive(env *Envelope) ([]byte, error)
 	DeliverMail(whisperPeer *Peer, request *Envelope)
 }
 
diff --git a/whisper/whisperv6/events.go b/whisper/whisperv6/events.go
index 1665539..6021b4a 100644
--- a/whisper/whisperv6/events.go
+++ b/whisper/whisperv6/events.go
@@ -17,6 +17,8 @@ const (
 	EventMailServerRequestCompleted EventType = "mailserver.request.completed"
 	// EventMailServerRequestExpired fires after mailserver the request TTL ends
 	EventMailServerRequestExpired EventType = "mailserver.request.expired"
+	// EventMailServerEnvelopeArchived fires after an envelope has been archived
+	EventMailServerEnvelopeArchived EventType = "mailserver.envelope.archived"
 )
 
 // EnvelopeEvent used for envelopes events.
@@ -24,4 +26,5 @@ type EnvelopeEvent struct {
 	Event EventType
 	Hash  common.Hash
 	Peer  discover.NodeID
+	Data  interface{}
 }
diff --git a/whisper/whisperv6/whisper.go b/whisper/whisperv6/whisper.go
index 4a7b006..ae4e058 100644
--- a/whisper/whisperv6/whisper.go
+++ b/whisper/whisperv6/whisper.go
@@ -378,8 +378,8 @@ func (whisper *Whisper) RequestHistoricMessages(peerID []byte, envelope *Envelop
 	return p2p.Send(p.ws, p2pRequestCode, envelope)
 }
 
-func (whisper *Whisper) SendHistoricMessageResponse(peer *Peer, requestID common.Hash) error {
-	size, r, err := rlp.EncodeToReader(requestID)
+func (whisper *Whisper) SendHistoricMessageResponse(peer *Peer, payload []byte) error {
+	size, r, err := rlp.EncodeToReader(payload)
 	if err != nil {
 		return err
 	}
@@ -835,15 +835,28 @@ func (whisper *Whisper) runMessageLoop(p *Peer, rw p2p.MsgReadWriter) error {
 			}
 		case p2pRequestCompleteCode:
 			if p.trusted {
-				var requestID common.Hash
-				if err := packet.Decode(&requestID); err != nil {
+				var payload []byte
+				if err := packet.Decode(&payload); err != nil {
 					log.Warn("failed to decode response message, peer will be disconnected", "peer", p.peer.ID(), "err", err)
 					return errors.New("invalid request response message")
 				}
 
+				// check if payload is the requestID or requestID + cursor
+				// requestID is the hash of the request envelope.
+				// cursor is the db key, 36 bytes: 4 for the timestamp + 32 for the envelope hash.
+				length := len(payload)
+				if length != common.HashLength && length != common.HashLength+36 {
+					log.Warn("invalid response message, peer will be disconnected", "peer", p.peer.ID(), "err", err, "payload size", length)
+					return errors.New("invalid response size")
+				}
+
+				requestID := common.BytesToHash(payload[:common.HashLength])
+				cursor := payload[common.HashLength:]
+
 				whisper.envelopeFeed.Send(EnvelopeEvent{
 					Hash:  requestID,
 					Event: EventMailServerRequestCompleted,
+					Data:  cursor,
 				})
 			}
 		default:
@@ -927,6 +940,10 @@ func (whisper *Whisper) add(envelope *Envelope, isP2P bool) (bool, error) {
 		whisper.postEvent(envelope, isP2P) // notify the local node about the new message
 		if whisper.mailServer != nil {
 			whisper.mailServer.Archive(envelope)
+			whisper.envelopeFeed.Send(EnvelopeEvent{
+				Hash:  envelope.Hash(),
+				Event: EventMailServerEnvelopeArchived,
+			})
 		}
 	}
 	return true, nil
